\documentclass[article]{jss}
\usepackage[utf8]{inputenc}
%\usepackage[nogin]{Sweave}
\usepackage{pdfpages}
%\usepackage{tikz}
%\usetikzlibrary{shapes.geometric, arrows}

%\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
%\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
%\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
%\tikzstyle{arrow} = [thick,->,>=stealth]


\newcommand{\bofr}{\mathcal{B}(\mathbb{R})}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\bs}{\backslash}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\BB}{\mathbb{B}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\FF}{\mathbb{F}}
\newcommand{\la}{\lambda}
\newcommand{\coola}{\mathcal{A}}
\newcommand{\coolm}{\mathcal{M}}
\newcommand{\cooll}{\mathcal{L}}
\newcommand{\ipl}{\langle}
\newcommand{\ipr}{\rangle}
\newcommand{\limn}{\lim_{n \to \infty}}
\newcommand{\lr}{\Leftrightarrow}
\newcommand{\set}[1]{\left\lbrace #1 \right\rbrace}
\renewcommand{\d}{\,\text{d}}
\newcommand{\pt}[1]{\left(#1\right)}
\newcommand{\fork}[1]{\left\{\begin{array}{lr}#1\end{array}\right.} % gaffel-funktion
\newcommand{\tuad}[1]{\qquad\ \text{#1}\ }
\newcommand{\ND}{\mathcal{N}}
\newcommand{\Perp}{\perp \! \! \! \perp}
\newcommand{\ddu}{\frac{\partial}{\partial u}}
\newcommand{\ddv}{\frac{\partial}{\partial v}}
\newcommand{\ddx}{\frac{\partial}{\partial x}}
\newcommand{\dds}{\frac{\partial}{\partial s}}
\newcommand{\ddt}{\frac{\partial}{\partial t}}
\newcommand{\dd}{\partial}
\newcommand{\g}{\cellcolor[gray]{0.5}}
\newcommand{\var}[1]{\textsc{\lowercase{#1}}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\rhomax}{\rho_{\text{max}}}
\newcommand{\D}{\text{D}}
\newcommand{\nperp}{\not\!\perp\!\!\!\perp}
\newcommand*\rot{\rotatebox{90}}
\newcommand{\green}[1]{\textcolor{OliveGreen}{#1}}
\newcommand{\s}[1]{\bar{#1}}
\newcommand{\us}[1]{\underbar{#1}}
\newcommand{\argmax}{\text{argmax}}

\newcommand{\plim}{\plimo_{n \to \infty}}
\newcommand{\asim}{\stackrel{as.}{\sim}}

\newcommand{\hl}[1]{\textcolor{magenta}{#1}}
\newcommand{\R}[1]{\texttt{#1}}

%\begin{center}
%\includegraphics[scale=0.3]{residualplot_logengel.jpeg} 
%\end{center} 
 
\begin{document}


\section{Introduction}

\section{Checking a dataset for errors}


\section{Customizing the cleanR output}
Though the discussion in the above paints a picture of cleanR as a user-friendly package which requires practically no knowledge of R, one should not be mistaken to think that it is not customizable. In fact, the main function of cleanR, \R{clean}, is mainly a tool for formatting the results from various checking-, summary- and visualizaion functions \hl{as described... blabla}. Thus, the actual work underlying a cleanR output file can be anything or nothing - depending on the arguments given to \R{clean}. This section consists of three parts. We commence this section with an overview of how contents are controlled in \R{cleanR} in terms of what cleaning steps are performed. Secondly, we turn to the possibilities of customizing what the final cleanR file looks like. Lastly, we go through an example of how to put all these customization options together in practice.

\subsection{Controlling contents}
By the \textit{contents} of the cleanR output, we refer to every step that actually involves a function being called on variables from the dataset. There are three stages in which this occurs \hl{(with ref. to figure/flowchart?)}:
\begin{enumerate}
\item In the precheck functions
\item In the summarize/visualize/check (SVC) step
\item In the multivariate visuzalizations \hl{Or whatever, in the stuff that we have not yet implemented. I'm pretending like this stage doesn't exist below.}
\end{enumerate}
Each of these stages are controllable using appropriate function parameters in \R{clean}. In the above, we presented the default \R{cleanR} settings and how to tweak them into providing a slightly different data cleaning outputs. However, if for instance the dataset at hand requires completely different visualizations, more control is needed. \R{cleanR} uses three different types of functions for performing all stages in the above, namely \R{summaryFunction}s, \R{visualFunction}s and \R{checkFunction}s. They each have distinct input-output structures and most instances of the functions are build as \R{S3} generics with methods for different data classes. By understanding how to construct proper \R{summaryFunction}s, \R{visualFunction}s and \R{checkFunction}s, the entire contents of the \R{cleanR} output is at your hands. Therefore, this section is dedicated to introducing each in turn.\\

\hl{Something like a figure that gives an overview of all summaryFunctions, ... available in standard cleanR, including default settings and some kind of description of where they are called (in precheck or SVC step). Also something about what datatypes they can each be called on. Also, more text here about the relationship between the two (three) stages and the three function types.}


\subsubsection{Writing a summaryFunction}
Though \R{cleanR} provides a special class for \R{summaryFunction}s, there really is nothing special about these functions: They are nothing but regular functions with a certain input/output-structure. Specifically, they all follow the template below:
\begin{Verbatim}
mySummaryFunction <- function(v) {
	res <- [result of whatever summary we are doing]
	list(feature = "Feature name", result = res)
}
\end{Verbatim}
and we recommend furthermore adding them to the overview of all summary functions by converting them to proper \R{summaryFunction} objects:
\begin{Verbatim}
mySummaryFunction <- summaryFunction(mySummaryFunction,
	description = "Some text describing what your summaryFunction does")
\end{Verbatim}
which adds the new function to the output of \R{allSummaryFunctions()}. Note that \R{v} is a vector and that \R{res} should be either a character string or something that will be printed as one. In other words, e.g. integers are allowed, but matrices are not. Though a lot of different things can go into the \R{summaryFunction} template, we recommend only using them for summarizing the features of a variable, and leaving tests and checks for the \R{checkFunction}s (presented below).

\subsubsection{Writing a visualFunction}
\R{visualFunction}s are the functions that produce the figures of a \R{cleanR} output document. Writing a visual function is slightly more complicated than writing a summary function. This follows from the fact that visualFunctions need to be able to output standalone code for plots in order for \R{clean} to build standalone rmarkdown files. We recommend using the following structure:
\begin{Verbatim}
myVisualFunction <- function(v, vnam, doEval) {
	thisCall <- call("[the name of the function used to produce the plot]", 
		v, [additional arguments to the plotting function])
	if (doEval) {
		return(eval(thisCall))
	} else return(deparse(thisCall)
}

myVisualFunction <- visualFunction(myVisualFunction, 
	description = "Some text describing your visualFunction")
\end{Verbatim}
In this function, \R{v} is the variable to be visualized, \R{vnam} is its name (which should generally be passed to \R{title} or \R{main} arguments in plotting functions) and \R{doEval} controls whether the output is a plot (if \R{TRUE}) or a character string of standalone code for producing a plot (if \R{FALSE}). The latter \R{doEval} setting is not strictly necessary for its use in \R{clean}, but it makes it easier to assess what visualization options are available. In either case, it should be noted that all the parameters listed above, \R{v}, \R{vnam} and \R{doEval}, are mandatory, so they should be left as is (\hl{as are?}), even if you do not want to use them. As with \R{summaryFunction}s, an overview of all available \R{visualFunction}s in the environment can be obtained by calling
\begin{Verbatim}
allVisualFunctions()
\end{Verbatim}
and by calling 
\begin{Verbatim}
allVisual(v, vnam, output = "html")
\end{Verbatim}
an overview of all plotting options applied on \R{v} is produced and opened as a html document for easy comparison. \hl{Should we mention the side effect of producing .rmd and .html files on disc?}


\subsubsection{Writing a checkFunction}
The last, but also most important, \R{cleanR} function type is the \R{checkFunction}. These are the functions that flag issues in the data and control the flow of the overall data cleaning process in the precheck stage. A \R{checkFunction} can be written using the following template:
\begin{Verbatim}
myCheckFunction <- function(v) {
	[do your check]
	problem <- [is there a problem? TRUE/FALSE]
	problemValues <- [vector of values in v that are problematic]
	problemStatus <- list(problem = problem, problemValues = problemValues)
	
	problemMessage <- "[The message that should be printed prior to listing 
			problem values in the cleanR output]"
	
	outMessage <- messageGenerator(list(problem = problem, 
		problemValues = problemValues, message = problemMessage))
	
	list(problem = problem, message = message) #problem is TRUE/FALSE,
		# message is a text string 
}
myCheckFunction <- checkFunction(myCheckFunction, 
	description = "[A description of your checkFunction]")
\end{Verbatim}
Only the input parameter (\R{v}) and the output format strictly has to follow this structure. However, we recommend using \R{messageGenerator} for consistent styling of all \R{checkFunction} messages. This function simply pastes together the \R{problemMessage} and the \R{problemValues}, with the latter being quoted and sorted alphabetically. Note that printing quotes in rmarkdown requires an extensive amount of character escaping, so opting for \R{messageGenerator} really is the easiest solution.

While the descriptions of \R{summaryFunction}s and \R{visualFunction}s are only for internal use in the \R{allSummaryFunctions()} and \R{allVisualFunctions()} outputs, respectively, \R{checkFunction} descriptions are actually visible in the \R{cleanR} output document. These are the brief descriptions presented in Part 1 \hl{eh? Is this clear? Whatever we call this section in the above} in the output document. If a \R{checkFunction} does not have a description (for instance, if it is just a regular \R{function} using the \R{checkFunction} input/output-structure), the function name will be printed instead of the description. 






\subsection{Controlling formatting}
\hl{Something about how to control what is printed where. Should be much briefer than the stuff in the above. This section could maybe include the following points:
\begin{enumerate}
\item Controlling "part 1", i.e. the stuff that is printed before the loop is started. 
\item The effect of prechecks.
\item A table containing other parameters that control formatting/stuff like this, e.g. twoCol, checkDetails (if we ever implement it), listChecks... 
\end{enumerate}
}

\subsection{Controlling flow?}
\hl{I feel like we maybe need yet another section about customization. We have not yet described the following (rather important(?)) features:
\begin{itemize}
\item The mode argument - controlling which SVC steps are performed
\item smartNum - chooosing whether or not numeric/integer variables with only a few levels are treated as factors
\item standAlone - Describing how it is possible to produce .Rmd files that can be included in other .Rmd files using the child option and standAlone = F (removing the YAML preamble (and maybe also the cleanR commerical? Are we that nice?)). 
\end{itemize}
}

\subsection{A worked example}
\hl{Maybe use the examples from the documentation to construct new summaryFunction etc. and add them to the default options. }

\section{To-dos in the code}
\hl{ ...  introduced by discrepancy between what I say we have done and what we have actually done:
\begin{itemize}
\item summaryFunction stuff:
	\begin{itemize}
		\item Make constructor function
		\item Make allSummaryFunctions()
		\item Change class of all summary (and description) functions into summaryFunction (possibly letting description functions be a subclass?)
		\item Maybe: Make clean check if summary functions are really summaryFunctions?
	\end{itemize}
\item visualFunction stuff:
	\begin{itemize}
		\item Make constructor function
		\item Make allVisualFunctions()
		\item Change class of all visual functions into visualFunction
		\item Maybe: Make clean check if visual functions are really visual functions?
	\end{itemize}
\item checkFunction stuff:
	\begin{itemize}
		\item Make allCheckFunctions()
		\item Work on messageGenerator() to make it better suited for being an exported function + export it
		\item Make allVisual()
	\end{itemize}
\end{itemize}
}

\end{document} 



