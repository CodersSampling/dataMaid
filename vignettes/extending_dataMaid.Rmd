---
title: "Extending dataMaid"
author: "Anne Helby Petersen and Claus Ekstrom"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Extending dataMaid}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE)
library(dataMaid)
```

#Introduction
The data documentation tools available in `dataMaid` allows for it to be utilized as an easy-to-use, self-contained package, as outlined in our [articlemanuscript](https://github.com/ekstroem/dataMaid/blob/master/latex/article_vol3.pdf). However, this does *not* imply that `dataMaid` is not customizable: `dataMaid` was specifically built for including user-made extenstions and this vignette is a tutorial into how one can write simple extensions that can be used in e.g. the `makeDataReport()` function of `dataMaid`. 

##Three steps of data documentation
In order to understand how different parts of the report creation can be customized, we will briefly dwelve on the structure of the data reports made by `dataMaid`. Aside from a few pages dedicated to gaining an overview of the full dataset and what was done to document its current state, the report consists of some information for each variable. More specically, each variable is presented with one of the two sets of information:

1. The result of a single check
2. The results of the three canonical `dataMaid` steps:
    + Summarize: Produces a summary table
    + Visualize: Produces a distribution visualization
    + Check: Performs and lists the results of a number of checks

The first option will be used for variables that do not pass the initial pre-checks. These are checks that are performed in order to identifying variables that are not elligable for detailed documentation for one reason or another. The default pre-checks used in `makeDataReport()` are 

* `isKey`: Check if the variable is a key, i.e. categorical with unique values for each observation 
* `isSingular`: Check if the variable only takes a single (non-`NA`) value
* `isSupported`: Check if the class of the variable is among the classes supported by `dataMaid`

If any of these checks finds a problem, the relevant problem will be mentioned in the report and the variable will not be exposed to further description steps. If the pre-checks do not flag a variable, on the other hand, the variable will be subjected to the three SVC (summarize, visualize, check) steps mentioned above. In the SVC-steps, `makeDataReport()` calls a number of so-called `summaryFunction`s, `visualFunction`s and `checkFunction`s, with different choices of functions depending on the class of the variable. The customizability features of `dataMaid` essentially comes down to writing functions such `summaryFunction`s, `visualFunction`s and `checkFunction`s. 

This vignette consists of two parts. First, we describe how new
`summaryFunction`s, `visualFunction`s and
`checkFunctions` can be made by describing the requirements to their structures that must be fulfilled in order for them to be used in a `makeDataReport()` call. Secondly,  we
turn to a worked example of how to use custom made functions in
practice. Here, we define and use four new SVC functions, both
interactively and in `makeDataReport()`. Lastly, the data report generated by using these customized functions is included.

In this vignette, we focus on the report creation tools of `dataMaid`. However, it should be emphasized that by following the guidelines presented here, the user-defined `summaryFunctions`, `visualFunctions` and `checkFunctions` will also be fully integrable with the interactive mode of `dataMaid`. 





#Function templates
In order to construct a summary, visual or check function, one needs
to create a new function with a specific structure.  This can be done with
different levels of strictness. If
the new custom function is only to be used as part of the SVC steps in `makeDataReport()`,
then only the input/output structure of the function needs special attention.
However, new user-defined functions can also be registered locally to
be part of the full machinery of `dataMaid`, and these function will
be recognized and behave in the same way as the built-in functions in
`dataMaid`. The presentation below is given in the format of
function templates, written in pseudo-code. These templates are
designed for getting the full functionality, but note that
the table above serves as a reference to the minimal
requirements, while also presenting the "full" versions of the
function types.

The table below serves as an overview
of the internals of the three central function types, `summaryFunction`, `visualFunction` and `checkFunction`. 


|   | `summaryFunction`    | `visualFunction`    | `checkFunction`    |
|---|----------------------|---------------------|--------------------|
| Input (required) | `v` - A variable vector. <br/> `...` - Additional arguments passed to the function. |  `v` - A variable vector. <br/> `vnam` - The variable name (as character string). <br/> `doEval` - A logical (`TRUE`/`FALSE`) controlling the output type of the function. | `v` - A variable vector <br/> `nMax` - An integer (or `Inf`), controlling how many problematic values are printed, if relevant <br/> `...` - Additional arguments passed to the function.|
| Input (optional) |  `maxDecimals` - The number of decimals printed in outputted numerical values.  |  |  `maxDecimals` - The number of decimals printed in outputted numerical values.|
|Purpose | Describe some aspect of the variable, e.g., a central value, its dispersion or level of missingness. | Produce a distribution plot. | Check a variable for a specific issue and, if relevant, identify the values in the variable that cause the issue. |
| Output (required) | A list with entries: <br/> `feature` - A label for the summary value (as character string);  <br/> `result` - The result of the summary (as character string). | A character string with `R` code for producing a plot. This code should be standalone, i.e., should include the data if necessary. | A list with entries: <br/> `problem` - A logical identifying whether an issue was found; <br/> `message` - A character string (possibly empty) decribing the issue that was found, properly escaped and ready for use with `rmarkdown`. |
| Output (recommended) | A `summaryResult` object, i.e., an attributed list with entries `feature`, `result` and `value`, the latter being the values from `result` in their original format). | If `doEval` is `TRUE`: A plot that is opened by the graphic device in `R`. <br/> If `doEval` is `FALSE`:  A text string with `R` code, as described above.  | A `checkResult` object, i.e., an attributed list with entries `problem`, `message` and `problemValues`, the latter being either `NULL` or the problem causing values, as they were found in `v`, whichever is relevant. |
| Tools available for producing the function | `summaryResult()` |  | `messageGenerator()` <br/> `checkResult()`|



##Writing a summaryFunction
As mentioned above, `dataMaid` provides a dedicated class for
`summaryFunction`s. However, this does not imply that they are
particularly advanced or complicated to create; in fact, they are
nothing but regular functions with a particular
input/output-structure. Specifically, they all follow the template
below:

```
mySummaryFunction <- function(v, ...) {
  res <- [result of whatever summary we are doing]
  summaryResult(list(feature = "[Feature name]", result = res))
}
``` 
The last function called here, `summaryResult()`, changes the
class of the output, thereby making a `print()` method available
for it.  Note that `v` is an input vector and that `res`
should be either a character string or something that will be printed
as one. In other words an integer would be allowed for `res`, 
but a matrix will not. Though a lot of different things can go into the
`summaryFunction` template, we recommend only using it for
summarizing the features of a variable, and leaving tests and checks
for the `checkFunction`s (presented below).

Adhering to the template above is sufficient for using the freshly
made `mySummaryFunction()` in `makeDataReport()`, but we recommend
adding the new function to the overview of all summary
functions by converting it to a proper `summaryFunction`
object. This is done by calling the `summaryFunction()` creator with
the user-defined function as the first argument, and additional arguments
`description` (an explanatory text which will be added to the attributes of
the function), and `classes` (a vector of variable classes the
user-defined function is intended to be applied to, also stored as an
attribute). In other words, a call following the template below should be made:

```
mySummaryFunction <- summaryFunction(mySummaryFunction,
  description = "[Text describing what the summaryFunction does]",
  classes = c([vector of data types that the function is intended
  for]))
``` 
which adds the new function to the output of an
`allSummaryFunctions()` call. If `mySummaryFunction` is
constructed as an `S3` generic function with associated methods,
the call to `summaryFunction()` will automatically produce a
vector of the names of the classes for which the function can be
called. If `mySummaryFunction()` is not an `S3` generic and
`classes` is left unspecified, the attribute will simply be left
empty. Note that the helper function `allClasses()` might be
useful for filling out the `classes` argument, as it simply lists
all available classes in `dataMaid`:

```{r sdf}
allClasses()
```


##Writing a visualFunction
`visualFunction`s are the functions that produce the figures in a
`dataMaid` output document. Writing a `visualFunction` is slightly
more complicated than writing a `summaryFunction`. This follows from
the fact that `visualFunction`s need to be able to output standalone
code for plots in order for `makeDataReport()` to build standalone
`rmarkdown` files. We recommend using the following structure
(again shown as pseudo code):

```
myVisualFunction <- function(v, vnam, doEval) {
  thisCall <- call("[the name of the function used to produce the plot]",
    v, [additional arguments for the plotting function])
  if (doEval) {
    return(eval(thisCall))
  } else return(deparse(thisCall))
}
```

In this function, `v` is the variable to be visualized,
`vnam` is its name (which should generally be passed to
`title` or `main` arguments in plotting functions) and
`doEval` controls whether the output is a plot (if `TRUE`)
or a character string of standalone code for producing a plot (if
`FALSE`). Implementing the `doEval = TRUE` setting is not
strictly necessary for a `visualFunction`'s use in `makeDataReport()`, but
it makes it easier to assess what visualization options are available,
and obviously, it is crucial for interactive usage of
`myVisualFunction()`. In either case, it should be noted that all
the parameters listed above, `v`, `vnam` and `doEval`,
are mandatory, so they must be left as is, even if they are not in
use (c.f., the table).


As with the summary function, we call `visualFunction()` to
register our newly created function:

```
myVisualFunction <- visualFunction(myVisualFunction,
  description = "[Some text describing the visualFunction]",
  classes = c([data types that this function is intended for]))
  )
```

Now, `myVisualFunction()` will be available in a `allVisualFunctions()`
call, just like the two build-in `visualFunction`s, `standardVisual`
and `basicVisual`.

##Writing a checkFunction
The last, but perhaps most important, `dataMaid` function type is
the `checkFunction`. These are the functions that flag issues in
the data as part of the check step and/or control the overall flow of the data
cleaning process in the pre-check stage. A `checkFunction` follows
one of two overall structures, depending on the type of check. Either,
it tries to identify problematic values in the variable (as
e.g., `identifyMissing()` does), or it performs a check concerning the
variable as a whole (e.g., the functions used for pre-checks and the
function `identifyNums()`). We present templates for both types of
`checkFunction`s below separately, but it should be emphasized that
formally, they belong to the same class.

First, a template for the full-variable check function type, where we
first define the function and subsequently register it as a check
function using `checkFunction()`:

```  
myFullVarCheckFunction <- function(v, ...) {
  [do your check]
  problem <- [is there a problem? TRUE/FALSE]
  message <- "[message describing the problem, if any]"
  checkResult(list(problem = problem,
    message = message,
    problemValues = NULL))
}

myFullVarCheckFunction <- checkFunction(myFullVarCheckFunction,
  description = "[Some text describing the checkFunction]",
  classes = c([the data types that this function is intended to be used for])
  )
```

Again, as with `summaryFunction`s and `visualFunction`s, the
change of function class by use of `checkFunction()` is not strictly
necessary. Note however, that if `myFullVarCheckFunction` is to be
used in the summarize/visualize/check steps in `makeDataReport()`, the
description attribute will be printed in the overview table in the
*Data cleaning summary* part of the output document.

If problematic values are to be identified, the template from above
should be expanded to follow a slightly more complicated structure
(again shown as pseudo-code):

```
myProbValCheckFunction <- function(v, nMax, maxDecimals, ...) {
  [do your check]
  problem <- [is there a problem? TRUE/FALSE]
  problemValues <- [vector of values in v that are problematic]
  problemStatus <- list(problem = problem,
                        problemValues = problemValues)

  problemMessage <- "[Message that is printed prior to listing
                     problem values in the dataMaid output,
                     ending with a colon]"

  outMessage <- messageGenerator(problemStatus, problemMessage, nMax)

  checkResult(list(problem = problem,
    message = outMessage,
    problemValues = problemValues))
}

myProbValCheckFunction <- checkFunction(myProbValCheckFunction,
  description = "[Some text describing the checkFunction]",
  classes = c([the data types that this function is intended to be used for])
)
```

One comment should be devoted to the helper function,
`messageGenerator()`.  This function's sole purpose is aiding
consistent styling of all `checkFunction` messages. The function
simply pastes together the `problemMessage` and the
`problemValues`, with the latter being quoted and sorted
alphabetically. If the `nMax` argument to `messageGenerator()` is
not `Inf`, only the first `nMax` problem values will be pasted
onto the message, accompanied by a comment about how many problem
values were left out (if any).  Note that printing quotes in
rmarkdown requires an extensive amount of character escaping, so
opting for `messageGenerator()` really is the easiest solution.

In the template above, the argument `maxDecimals` is not in use. This
argument should be used to round off the `problemValues` passed to
`messageGenerator()`, if they are numerical.  This can be done by
adding an extra line of code after defining `problemStatus` in the template
above:

```  
myProbValCheckFunction <- function(v, nMax, maxDecimals, ...) {
  [... more lines of code here ...]
  problemStatus <- list(problem = problem,
    problemValues = problemValues)

  if (!is.null(problemValues)) {
    problemStatus$problemValues <- round(problemValues, maxDecimals)
  }
  [... more lines of code here ...]
}
```

Now, problematic values will be rounded in the outputted message, while they
will still appear in their original format under the entry `problemValues`
in the returned object.

#A worked example

As an example, we create some new functions and show both how they can be
used interactively and how they can be integrated with the `makeDataReport()`
function. These new functions are:

* New `summaryFunctions`: 
    + **`countZeros()`**: A new `summaryFunction` that counts the number of occurrences of the value `0` in a variable. This function will be used in the *summarize* step of `makeDataReport()`.
* New `visualFunctions`:  
    + **`mosaicVisual()`**: A new `visualFunction` that produces mosaic plots. This function will be used in the *visualize* step of `makeDataReport()`.
    + **`prettierHist()`**: ... 
* New `checkFunctions`: 
    + **`isID()`**: A new `checkFunction` intended for use in the pre-check-stage. This function checks whether a variable consists exclusively of long ($> 10$ characters/digits) entries that are all of equal length, as this might be personal identification codes that we do not wish to print out in the data summary.
    + **`identifyColons()`** A new `checkFunction` that flags variables in which values have colons that appear before and after alphanumerical characters. This is practical for identifying autogenerated interaction effects. This function will be used in the *check* step of `makeDataReport()`.

These functions are defined in turn below, and afterwards, an example of how they can be called from `makeDataReport()` is provided.

##summaryFunction examples: countZeros() and .. .

###countZeros --- somethingsomething

This `summaryFunction` is defined in the following lines of code:

```{r a4}
countZeros <- function(v, ...) {
  res <- length(which(v == 0))
  summaryResult(list(feature = "No. zeros", result = res, value = res))
}
```

As this function computes an integer (the number of zeros),
there is no difference between the elements `\$result` and
`\$value`. If, on the other hand, the result had been a character
string, extra formatting might be required in the `\$result` entry
(such as escaping of quotation marks), and in this scenario, the two
entries would have differed. As the result is returned as a
`summaryResult` object, a printing method is automatically called
when `countZeros()` is used interactively:

```{r a3}
countZeros(c(rep(0, 5), 1:100))
```

As with `mosaicVisual()`, we change the class of this function in
order to make it appear in `allSummaryFunctions()` calls. But now we
wish to emphasize that the function is not intended to be called on
all variable types, as zeros have different roles in `Date`s and in
`logical` variables:

```{r a2}
countZeros <- summaryFunction(countZeros,
  description = "Count number of zeros",
  classes = c("character", "factor", "integer",
              "labelled", "numeric"))
```


##visualFunction examples: mosaicVisual() and prettierHist() 
Blablabla

###mosaicVisual --- a new visualFunction for categorical data

`R` provides a function, `mosaicplot()`, which produces
mosaic plots. We intend to use this existing high-level plotting
function as part of the new visualization function.  We will define
the new function such that it gets the full `dataMaid`
functionality. This can be done using the following code which sets up
the call using the existing function `mosaicplot()`.

```{r a8}
mosaicVisual <- function(v, vnam, doEval) {
  thisCall <- call("mosaicplot", table(v), main = vnam, xlab = "")
  if (doEval) {
    return(eval(thisCall))
  } else return(deparse(thisCall))
}
```

This function can now be called directly or used in `makeDataReport()`, as will
presented in an example below. Depending on the `doEval` argument, either a text string
with code or a plot is produced. The plot resulting from the following
call is found in Figure~\ref{fig:mosaicPlot}:

```{r a7}
mosaicVisual(toyData$var1, "variable 1", doEval = TRUE)
```

Even though `mosaicVisual()`, as written above, follows the style of a
`visualFunction`, it is not yet truly one and therefore, it will not
appear in an `allVisualFunctions()` call. In order to get this
functionality we need to change its object class. This can be done by
writing

```{r a6}
mosaicVisual <- visualFunction(mosaicVisual,
                               description = "Mosaic plots using graphics",
                               classes = allClasses())
```  

Here, we use the function `allClasses()` to quickly obtain a vector
of all the seven variable classes addressed in `dataMaid`. Note that
if `mosaicVisual()` were an S3 generic function, this argument could
have been left as `NULL` and then the classes for which methods are
available would be added automatically.

As `mosaicVisual()` is now a full-blooded `visualFunction`, it
will also be included in the `allVisualFunctions()` output table:

```{r a5}
allVisualFunctions()
```

Now that we are done with the definition of `mosaicVisual()` we can
turn to the next function in line, `countZeros()`.

###prettierHist() --- a customized ggplot2 histogram 



##checkFunction examples: isID() and identifyColons() 
Blabla BLA


###isID --- a new checkFunction without problem values

First, let's define the `isID()` function. As this function is
not supposed to list problematic values, it falls within the category
of `checkFunction`s represented by
`myFullVarCheckFunction()` above. We do not particularly wish to
use this function interactively, so we will stick to the minimal
requirements of a `checkFunction` used in `check()` (see
Table~\ref{table.functionTypes}). The function can then be defined by

```{r a9}
isID <- function(v, nMax = NULL, ...) {
  out <- list(problem = FALSE, message = "")
  if (class(v) %in% setdiff(allClasses(), c("logical", "Date"))) {
    v <- as.character(v)
    lengths <- c(nchar(v))
    if (all(lengths > 10) & length(unique(lengths)) == 1) {
      out$problem <- TRUE
      out$message <- "Warning: This variable seems to contain ID codes."
    }
  }
out
}
```

This is essentially all we need to do in order to include this
function as a pre-check-function in `makeDataReport()`, so we will leave it as
is and move on to the next function, namely `mosaicVisual()`.


###identifyColons --- a new checkFunction with problem values

The last function mentioned above is `identifyColons()`. We
define it using the helper function `messageGenerator()` to
obtain a properly escaped message, and we use `checkResult()` to
make its output print neatly. In the code we use regular expressions
through the `gregexpr()` function to identify colons between two
words.

```{r a1}
identifyColons <- function(v, nMax = Inf, ... ) {
  v <- unique(na.omit(v))
  problemMessage <- "Note: The following values include colons:"
  problem <- FALSE
  problemValues <- NULL
  
  problemValues <- v[sapply(gregexpr("[[:xdigit:]]:[[:xdigit:]]", v),
                            function(x) all(x != -1))]

  if (length(problemValues) > 0) {
    problem <- TRUE
  }

  problemStatus <- list(problem = problem,
  problemValues = problemValues)

  outMessage <- messageGenerator(problemStatus, problemMessage, nMax)

  checkResult(list(problem = problem,
  message = outMessage,
  problemValues = problemValues))
}
```

Once again, we change the class of the function so that it becomes a
proper `checkFunction` object:

```{r a}
identifyColons <- checkFunction(identifyColons,
                                description = "Identify colons surrounded by alphanumeric characters",
                                classes = c("character", "factor", "labelled"))
```

Note, that for `checkFunction`s, the description will appear in
the document produced by `makeDataReport()` (in the *Data cleaning
  summary* section of the output), so for this type of function, the
change of class is not only done for the sake of the
`allCheckFunctions()` output.


##Calling the new summarize/visualize/check functions from makeDataReport()

Now, we are ready to use these new functions in a `makeDataReport()`
call. The extended `dataMaid` output document should have the
following modifications, relative to the standard `dataMaid` output:

* We want to add the new pre-check function, `isID()`, to the already existing pre-checks.
* We wish to change the plot type for all variables to the new mosaic plot.
* We want the new summary function, `countZeros()`, to be added to the summaries performed on all variable types but `Date` and `logical`.
* We want the new check function, `identifyColons()`, to be added to the checks performed on `character`, `factor` and `labelled` variables.

These options are specified as follows:



```{r makeSecondReport, message  = FALSE}
data("exampleData")
makeDataReport(exampleData,
      preChecks = c("isKey", "isSingular", "isSupported", "isID"),
      visuals = setVisuals(character = "mosaicVisual",
                           factor = "mosaicVisual",
                           labelled = "mosaicVisual"), 
      summaries = setSummaries(character = defaultCharacterSummaries(add = "countZeros"),
                               factor = defaultFactorSummaries(add = "countZeros"),
                               labelled = defaultLabelledSummaries(add = "counZeros"),
                               numeric = defaultNumericSummaries(add = "countZeros"),
                               integer = defaultIntegerSummaries(add = "countZeros")),
      checks = setChecks(character = defaultCharacterChecks(add = "identifyColons"),
                         factor = defaultFactorChecks(add = "identifyColons"),
                         labelled = defaultLabelledChecks(add = "identifyColons")),
      replace = TRUE, 
      output = "html",
      open = FALSE)
```  

We have chosen the output to be html (`output = "html"`) so that it can easily be included in this vignette by use of the `includeHTML()` function from the `htmltools` package. We have set `open = FALSE` so that the outputted rmarkdown file is not opened automatically. The outputted report is available at the end of this vignette. A few comments...


#A dataMaid report: Documenting exampleData

We include the report documenting `exampleData`:

```{r hithere}
htmltools::includeHTML("dataMaid_exampleData.html")
```
